<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Engebeli Bisiklet</title>
<link href="https://fonts.googleapis.com/css2?family=Caveat:wght@400;700&display=swap" rel="stylesheet">
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { overflow:hidden; background:#edeae0; font-family:'Caveat',cursive; }
canvas { display:block; }
#hud { position:fixed; top:16px; left:50%; transform:translateX(-50%); color:#4a3828; font-size:22px; pointer-events:none; text-shadow:1px 1px 0 rgba(255,255,255,0.6); letter-spacing:1px; }
#tip { position:fixed; bottom:18px; left:50%; transform:translateX(-50%); color:#7a6858; font-size:17px; pointer-events:none; background:rgba(237,234,224,0.78); padding:6px 20px; border-radius:14px; border:1.5px dashed #c0a87a; white-space:nowrap; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud">ğŸš² Engebeli Yolculuk</div>
<div id="tip">â† â†’ Hareket &nbsp;|&nbsp; â†‘ HÄ±zlan &nbsp;|&nbsp; â†“ Fren</div>
<script>
const cv = document.getElementById('c');
const cx = cv.getContext('2d');
let W, H;
const resize = () => { W = cv.width = innerWidth; H = cv.height = innerHeight; };
resize(); addEventListener('resize', resize);

// â”€â”€â”€ utils â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const lerp  = (a,b,t) => a + (b-a)*t;
const clamp = (v,a,b) => v<a?a:v>b?b:v;
const rnd   = (a,b)   => a + Math.random()*(b-a);

// â”€â”€â”€ Terrain â€“ very smooth, low-frequency only â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Using just 3 gentle sine waves so bumps are wide rolling hills
function ty(wx) {
  return Math.sin(wx * 0.0055) * 48       // big lazy hills
       + Math.sin(wx * 0.014  + 1.3) * 24 // medium undulations
       + Math.sin(wx * 0.033  + 0.7) * 10 // gentle ripples
       + Math.sin(wx * 0.07   + 2.1) * 4; // tiny variation
}
// Ground Y in screen coords given camera worldX
function gy(wx, camX) { return H * 0.63 + ty(wx); }
// Terrain slope angle at wx
function tangle(wx) {
  const d = 5;
  return Math.atan2(ty(wx+d)-ty(wx-d), d*2);
}

// â”€â”€â”€ Input â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const K = {};
addEventListener('keydown', e => { K[e.key]=true;  e.preventDefault(); });
addEventListener('keyup',   e => { K[e.key]=false; });

// â”€â”€â”€ Bike physics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const FWR = 36, RWR = 20; // front/rear wheel radius
let camX  = 0;  // world X of camera / bike
let velX  = 0;
let lean  = 0;
let bAngle= 0;  // body angle (terrain slope)
let fRot  = 0, rRot = 0;
let bY    = 0;  // current screen Y of ground contact
let jmp   = 0, jmpV = 0; // vertical bounce

// â”€â”€â”€ Background data (world-space, fixed) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Each item has worldX. We derive screenX = W/2 + (item.wx - camX * parallax)
// Because items have fixed worldX positions, they never drift or jitter.

const LAYERS = [
  { par: 0.08, items: [] },  // distant mountains
  { par: 0.22, items: [] },  // mid trees
  { par: 0.50, items: [] },  // near trees + houses
  { par: 1.00, items: [] },  // foreground flowers + rocks (move 1:1 with terrain)
];

(function buildBg() {
  const R = 7000; // world range
  // Mountains
  for (let i = 0; i < 24; i++) LAYERS[0].items.push({
    t:'mt', wx:rnd(-R,R), w:rnd(130,300), h:rnd(80,200),
    col:`rgba(${~~rnd(148,192)},${~~rnd(138,182)},${~~rnd(122,162)},0.44)`
  });
  // Mid trees
  for (let i = 0; i < 50; i++) LAYERS[1].items.push({
    t:'tr', wx:rnd(-R,R), th:rnd(55,135),
    col:`rgba(${~~rnd(82,125)},${~~rnd(110,152)},${~~rnd(62,102)},0.65)`
  });
  // Near trees + houses
  for (let i = 0; i < 30; i++) LAYERS[2].items.push({
    t:'tr', wx:rnd(-R,R), th:rnd(45,105),
    col:`rgba(${~~rnd(75,115)},${~~rnd(105,145)},${~~rnd(58,98)},0.80)`
  });
  for (let i = 0; i < 10; i++) LAYERS[2].items.push({
    t:'hs', wx:rnd(-R,R), w:rnd(52,92),
    col:`rgba(${~~rnd(188,225)},${~~rnd(168,205)},${~~rnd(148,185)},0.88)`
  });
  // Foreground: flowers + rocks sit ON the terrain
  for (let i = 0; i < 100; i++) LAYERS[3].items.push({
    t:'fl', wx:rnd(-R,R),
    col:['#e84f5e','#e8902a','#cc4ea5','#4e9ee5','#5dc05d'][~~rnd(0,5)]
  });
  for (let i = 0; i < 35; i++) LAYERS[3].items.push({
    t:'rk', wx:rnd(-R,R), w:rnd(7,20)
  });
})();

// Clouds are in screen-space (no world coords) â€” purely decorative drift
const clouds = Array.from({length:8}, () => ({
  x: rnd(0, W), y: rnd(H*0.03, H*0.26), w: rnd(85,200), vx: rnd(-0.11,-0.04)
}));
// Birds likewise
const birds = Array.from({length:5}, () => ({
  x: rnd(0,W), y: rnd(H*0.07, H*0.35), vx: rnd(0.22,0.6), ph: rnd(0,Math.PI*2)
}));
// Dust particles â€“ screen space
const dust = Array.from({length:20}, () => ({
  x: rnd(0,W), y: rnd(H*0.4,H*0.85), vx: rnd(-0.28,-0.04), vy: rnd(-0.18,0.14),
  life: rnd(0,1), sz: rnd(1,3.2), leaf: Math.random()<0.38
}));

// â”€â”€â”€ Draw helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Smooth line (slight bezier bow for sketch feel)
function sline(x1,y1,x2,y2) {
  const mx=(x1+x2)/2, my=(y1+y2)/2;
  cx.beginPath();
  cx.moveTo(x1,y1);
  cx.quadraticCurveTo(mx+(y2-y1)*0.03, my-(x2-x1)*0.03, x2,y2);
  cx.stroke();
}
function scirc(x,y,r) { cx.beginPath(); cx.arc(x,y,r,0,Math.PI*2); cx.stroke(); }

// â”€â”€â”€ Terrain rendering â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawTerrain() {
  // Sky
  const sky = cx.createLinearGradient(0,0,0,H*0.65);
  sky.addColorStop(0,'#bfe4f8'); sky.addColorStop(0.65,'#e6f3fa'); sky.addColorStop(1,'#edeae0');
  cx.fillStyle = sky; cx.fillRect(0,0,W,H);

  // Terrain polygon
  const sx0 = -20, sx1 = W+20;
  // Convert screen X â†’ world X: wx = camX + (sx - W/2)
  cx.beginPath();
  let first = true;
  for (let sx = sx0; sx <= sx1; sx += 3) {
    const wx = camX + (sx - W/2);
    const sy = H*0.63 + ty(wx);
    first ? (cx.moveTo(sx,sy), first=false) : cx.lineTo(sx,sy);
  }
  cx.lineTo(sx1, H+10); cx.lineTo(sx0, H+10); cx.closePath();

  const gfill = cx.createLinearGradient(0,H*0.4,0,H);
  gfill.addColorStop(0,'#b6d075'); gfill.addColorStop(0.12,'#a4c065'); gfill.addColorStop(0.55,'#94b055'); gfill.addColorStop(1,'#84a045');
  cx.fillStyle = gfill; cx.fill();

  // Terrain outline
  cx.beginPath(); first=true;
  for (let sx = sx0; sx <= sx1; sx += 3) {
    const wx = camX + (sx - W/2);
    const sy = H*0.63 + ty(wx);
    first ? (cx.moveTo(sx,sy), first=false) : cx.lineTo(sx,sy);
  }
  cx.strokeStyle='#608035'; cx.lineWidth=2; cx.lineJoin='round'; cx.lineCap='round'; cx.stroke();

  // Dirt strip just below surface
  cx.save();
  cx.beginPath(); first=true;
  for (let sx = sx0; sx <= sx1; sx += 3) {
    const wx = camX + (sx - W/2);
    const sy = H*0.63 + ty(wx);
    first ? (cx.moveTo(sx,sy), first=false) : cx.lineTo(sx,sy);
  }
  cx.lineTo(sx1,H+10); cx.lineTo(sx0,H+10); cx.closePath(); cx.clip();
  const dg = cx.createLinearGradient(0,H*0.6,0,H*0.6+30);
  dg.addColorStop(0,'rgba(148,110,58,0.28)'); dg.addColorStop(1,'rgba(148,110,58,0)');
  cx.fillStyle=dg; cx.fillRect(0,H*0.3,W,H);
  cx.restore();
}

// â”€â”€â”€ Background item drawing â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// sx = screen X, groundSY = screen Y of terrain at that spot
function drawItem(item, sx, groundSY) {
  if (sx < -400 || sx > W+400) return;
  cx.save(); cx.lineCap='round'; cx.lineJoin='round';

  if (item.t === 'mt') {
    cx.fillStyle=item.col; cx.strokeStyle='rgba(90,80,70,0.25)'; cx.lineWidth=1.2;
    cx.beginPath(); cx.moveTo(sx-item.w/2,groundSY); cx.lineTo(sx,groundSY-item.h); cx.lineTo(sx+item.w/2,groundSY); cx.closePath();
    cx.fill(); cx.stroke();
    cx.fillStyle='rgba(255,255,255,0.50)';
    cx.beginPath(); cx.moveTo(sx-item.w*0.10,groundSY-item.h*0.75); cx.lineTo(sx,groundSY-item.h); cx.lineTo(sx+item.w*0.10,groundSY-item.h*0.75); cx.closePath(); cx.fill();
  }
  else if (item.t === 'tr') {
    const th=item.th;
    cx.strokeStyle='#7a5535'; cx.lineWidth=Math.max(2,th*0.042);
    sline(sx,groundSY,sx,groundSY-th*0.42);
    cx.fillStyle=item.col; cx.strokeStyle='#4a6535'; cx.lineWidth=1.3;
    cx.beginPath(); cx.arc(sx,groundSY-th*0.66,th*0.34,0,Math.PI*2); cx.fill(); cx.stroke();
    cx.beginPath(); cx.arc(sx-th*0.16,groundSY-th*0.50,th*0.21,0,Math.PI*2); cx.fill();
    cx.beginPath(); cx.arc(sx+th*0.18,groundSY-th*0.52,th*0.22,0,Math.PI*2); cx.fill();
    cx.beginPath(); cx.arc(sx,groundSY-th*0.82,th*0.18,0,Math.PI*2); cx.fill();
  }
  else if (item.t === 'hs') {
    const hw=item.w, hh=hw*0.68;
    cx.fillStyle=item.col; cx.strokeStyle='#685038'; cx.lineWidth=1.5;
    cx.beginPath(); cx.rect(sx-hw/2,groundSY-hh,hw,hh); cx.fill(); cx.stroke();
    cx.fillStyle='rgba(180,108,88,0.78)';
    cx.beginPath(); cx.moveTo(sx-hw/2-4,groundSY-hh); cx.lineTo(sx,groundSY-hh-hw*0.52); cx.lineTo(sx+hw/2+4,groundSY-hh); cx.closePath(); cx.fill(); cx.stroke();
    cx.fillStyle='rgba(138,95,60,0.90)'; cx.beginPath(); cx.rect(sx-hw*0.12,groundSY-hh*0.44,hw*0.24,hh*0.44); cx.fill();
    cx.fillStyle='rgba(190,222,255,0.58)'; cx.strokeStyle='#886858'; cx.lineWidth=1;
    cx.beginPath(); cx.rect(sx+hw*0.16,groundSY-hh*0.76,hw*0.22,hh*0.26); cx.fill(); cx.stroke();
  }
  else if (item.t === 'fl') {
    cx.strokeStyle='#657838'; cx.lineWidth=1; sline(sx,groundSY,sx,groundSY-13);
    cx.fillStyle=item.col;
    for (let p=0;p<5;p++) { const a=p/5*Math.PI*2; cx.beginPath(); cx.arc(sx+Math.cos(a)*4.5,groundSY-13+Math.sin(a)*4.5,3.2,0,Math.PI*2); cx.fill(); }
    cx.fillStyle='#ffd860'; cx.beginPath(); cx.arc(sx,groundSY-13,2.8,0,Math.PI*2); cx.fill();
  }
  else if (item.t === 'rk') {
    cx.fillStyle='rgba(135,120,105,0.72)'; cx.strokeStyle='#887868'; cx.lineWidth=1;
    cx.beginPath(); cx.ellipse(sx,groundSY-item.w*0.33,item.w,item.w*0.50,0,0,Math.PI*2); cx.fill(); cx.stroke();
  }
  cx.restore();
}

// â”€â”€â”€ Wheel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawWheel(x,y,r,rot) {
  cx.save(); cx.lineCap='round';
  cx.strokeStyle='#1c0e06'; cx.lineWidth=r>27?4.5:3;
  scirc(x,y,r);
  cx.fillStyle='#1c0e06'; cx.beginPath(); cx.arc(x,y,r*0.11,0,Math.PI*2); cx.fill();
  cx.strokeStyle='rgba(50,28,8,0.80)'; cx.lineWidth=r>27?1.7:1.2;
  const ns = r>27?10:7;
  for (let i=0;i<ns;i++) {
    const a = rot + i/ns*Math.PI*2;
    cx.beginPath();
    cx.moveTo(x+Math.cos(a)*r*0.11, y+Math.sin(a)*r*0.11);
    cx.lineTo(x+Math.cos(a)*r*0.91, y+Math.sin(a)*r*0.91);
    cx.stroke();
  }
  cx.strokeStyle='rgba(65,40,12,0.32)'; cx.lineWidth=1; scirc(x,y,r*0.54);
  cx.restore();
}

// â”€â”€â”€ Bike â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawBike(sx, sy, velX, lean, fr, rr, ta) {
  cx.save();
  cx.translate(sx, sy);
  cx.rotate(ta * 0.55 + lean * 0.035);
  cx.lineCap='round'; cx.lineJoin='round';

  // penny-farthing layout: big front, small rear
  const fw = { x:30, y:FWR };
  const rw = { x:-28, y: RWR + (FWR-RWR) };

  // Rear wheel (drawn first = behind)
  drawWheel(rw.x, rw.y, RWR, rr);

  // Frame geometry
  const bb   = { x:2,   y:FWR-5  };
  const seat = { x:-12, y:FWR-44 };
  const head = { x:28,  y:FWR-28 };
  const hb   = { x:28,  y:FWR-5  };

  cx.strokeStyle='#28140a'; cx.lineWidth=2.5;
  sline(bb.x,bb.y, rw.x,rw.y);         // chain stay
  sline(seat.x,seat.y, rw.x,rw.y);     // seat stay
  sline(bb.x,bb.y, seat.x,seat.y);     // seat tube
  sline(seat.x,seat.y-2, head.x,head.y); // top tube
  sline(bb.x,bb.y, hb.x,hb.y);         // down tube
  sline(hb.x,hb.y, fw.x,fw.y);         // fork

  // Front wheel (drawn on top of fork)
  drawWheel(fw.x, fw.y, FWR, fr);

  // Handlebar
  cx.strokeStyle='#28140a'; cx.lineWidth=2.2;
  sline(head.x,head.y, head.x+2,head.y-14);
  sline(head.x-6,head.y-13, head.x+14,head.y-11);

  // Seat post + saddle
  cx.lineWidth=2.2;
  sline(seat.x,seat.y, seat.x-1,seat.y-14);
  cx.strokeStyle='#583515'; cx.lineWidth=3.5;
  cx.beginPath();
  cx.moveTo(seat.x-10,seat.y-13);
  cx.bezierCurveTo(seat.x-4,seat.y-17,seat.x+5,seat.y-17,seat.x+10,seat.y-13);
  cx.stroke();

  // Crank + pedals
  const crA = rr * (FWR/10);
  cx.strokeStyle='#28140a'; cx.lineWidth=2;
  const cl=14;
  const p1={x:bb.x+Math.cos(crA)*cl,       y:bb.y+Math.sin(crA)*cl};
  const p2={x:bb.x+Math.cos(crA+Math.PI)*cl,y:bb.y+Math.sin(crA+Math.PI)*cl};
  sline(bb.x,bb.y,p1.x,p1.y); sline(bb.x,bb.y,p2.x,p2.y);
  const pa=crA+Math.PI/2; cx.strokeStyle='#483018'; cx.lineWidth=3;
  for (const p of [p1,p2]) {
    cx.beginPath(); cx.moveTo(p.x+Math.cos(pa)*5,p.y+Math.sin(pa)*5); cx.lineTo(p.x-Math.cos(pa)*5,p.y-Math.sin(pa)*5); cx.stroke();
  }

  // Rider
  const hipX=seat.x-1, hipY=seat.y-13;
  const shX=hipX+13,   shY=hipY-25;
  const hdX=shX+5,     hdY=shY-17;

  // Legs
  cx.strokeStyle='#382618'; cx.lineWidth=2.8;
  const kA=crA+0.85;
  const k1={x:hipX+Math.cos(kA)*20,       y:hipY+Math.sin(kA)*20};
  const k2={x:hipX+Math.cos(kA+Math.PI)*17,y:hipY+Math.sin(kA+Math.PI)*17};
  cx.beginPath(); cx.moveTo(hipX,hipY); cx.lineTo(k1.x,k1.y); cx.lineTo(p1.x,p1.y); cx.stroke();
  cx.beginPath(); cx.moveTo(hipX,hipY); cx.lineTo(k2.x,k2.y); cx.lineTo(p2.x,p2.y); cx.stroke();

  // Torso
  cx.strokeStyle='#382618'; cx.lineWidth=3;
  cx.beginPath(); cx.moveTo(hipX,hipY); cx.bezierCurveTo(hipX+5,hipY-10,shX-5,shY+5,shX,shY); cx.stroke();

  // Arms
  cx.lineWidth=2.2; sline(shX,shY,head.x+2,head.y-12);

  // Head
  cx.fillStyle='#f0dcc0'; cx.strokeStyle='#28140a'; cx.lineWidth=1.8;
  cx.beginPath(); cx.arc(hdX,hdY,9,0,Math.PI*2); cx.fill(); cx.stroke();
  cx.fillStyle='#583818'; cx.beginPath(); cx.arc(hdX,hdY-3,9.5,Math.PI*1.05,Math.PI*2.1); cx.fill();
  cx.strokeStyle='#b84525'; cx.lineWidth=2;
  cx.beginPath(); cx.arc(hdX,hdY-5,8,Math.PI*1.2,Math.PI*2.0); cx.stroke();

  // Speed lines
  if (Math.abs(velX) > 1.5) {
    cx.strokeStyle='rgba(70,50,30,0.16)'; cx.lineWidth=1.2;
    for (let i=0;i<5;i++) {
      const lx=-62-i*13, ly=lerp(-28,18,i/4), len=rnd(10,26)*Math.abs(velX)/4;
      sline(lx,ly,lx-len,ly);
    }
  }
  cx.restore();
}

// â”€â”€â”€ Clouds / birds â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
function drawCloud(cl) {
  cx.save();
  const ps=[[0,0,cl.w*0.28],[cl.w*0.22,-cl.w*0.07,cl.w*0.22],[cl.w*0.44,cl.w*0.02,cl.w*0.24],[cl.w*0.18,cl.w*0.07,cl.w*0.20],[cl.w*0.62,cl.w*0.02,cl.w*0.20]];
  cx.fillStyle='rgba(255,255,255,0.90)'; cx.strokeStyle='rgba(168,155,135,0.50)'; cx.lineWidth=1.2;
  ps.forEach(([px,py,pr]) => { cx.beginPath(); cx.arc(cl.x+px,cl.y+py,pr,0,Math.PI*2); cx.fill(); });
  ps.forEach(([px,py,pr]) => { scirc(cl.x+px,cl.y+py,pr); });
  cx.restore();
}
function drawBird(b, t) {
  const bx=b.x, by=b.y+Math.sin(t*2.2+b.ph)*8, fl=Math.sin(t*6+b.ph)*7;
  cx.save(); cx.strokeStyle='#685840'; cx.lineWidth=1.5; cx.lineCap='round';
  cx.beginPath(); cx.moveTo(bx-11,by+fl); cx.quadraticCurveTo(bx,by,bx+11,by+fl); cx.stroke();
  cx.restore();
}

// â”€â”€â”€ Main loop â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
let t=0, last=0;

function loop(ts) {
  const dt = clamp((ts-last)/16, 0.1, 3);
  last=ts; t+=0.016*dt;

  // Input
  if (K['ArrowRight']||K['ArrowUp'])   velX = clamp(velX+0.14*dt, -2.5, 6);
  else if (K['ArrowLeft']||K['ArrowDown']) velX = clamp(velX-0.20*dt, -2.5, 6);
  else velX *= Math.pow(0.93,dt);
  if (Math.abs(velX)<0.01) velX=0;

  camX += velX*dt;
  lean  = lerp(lean, velX*-0.40, 0.08*dt);

  fRot += velX*dt*(0.95/FWR);
  rRot += velX*dt*(0.95/RWR);

  // Terrain angle at bike position
  const ta = tangle(camX);
  bAngle = lerp(bAngle, ta, 0.12*dt);

  // Vertical spring â€“ bike bounces onto terrain surface
  const groundY = H*0.63 + ty(camX);
  jmpV += (groundY - (bY + jmp)) * 0.07 * dt;
  jmpV *= Math.pow(0.78,dt);
  jmp  += jmpV * dt;
  bY    = groundY;
  if (jmp > 0) { jmp=0; jmpV=Math.min(0,jmpV); }

  // Clouds drift
  clouds.forEach(cl => { cl.x += cl.vx*dt; if(cl.x < -cl.w-50) cl.x=W+cl.w+50; });
  birds.forEach(b   => { b.x  += b.vx*dt;  if(b.x  > W+150)    b.x=-150; });

  // Dust particles
  dust.forEach(p => {
    p.x+=p.vx*dt - velX*0.30*dt; p.y+=p.vy*dt; p.life-=0.0035*dt;
    if(p.life<=0||p.x<-60||p.x>W+60){
      p.x=velX>0?W+rnd(0,60):rnd(-60,0);
      p.y=rnd(H*0.45,H*0.82); p.life=rnd(0.5,1);
      p.vx=rnd(-0.25,-0.03); p.vy=rnd(-0.22,0.16); p.sz=rnd(1,3.2);
    }
  });

  // â”€â”€â”€ Render â”€â”€
  cv.getContext('2d'); // ensure context alive
  cx.clearRect(0,0,W,H);

  drawTerrain();
  clouds.forEach(drawCloud);
  birds.forEach(b => drawBird(b,t));

  // Background layers
  // KEY FIX: screen X = W/2 + (item.wx - camX * parallax)
  // This means the item's world position is item.wx / parallax
  // so as camX grows, item moves left by camX*parallax â€“ stable, no jitter.
  LAYERS.forEach(layer => {
    layer.items.forEach(item => {
      const screenX = W/2 + (item.wx - camX * layer.par);
      if (screenX < -400 || screenX > W+400) return;

      let groundSY;
      if (layer.par >= 1.0) {
        // Foreground items sit exactly on the terrain
        const wx = camX + (screenX - W/2);
        groundSY = H*0.63 + ty(wx);
      } else {
        // Background items use flat horizon line scaled by parallax depth
        groundSY = H * (0.63 - 0.04*(1-layer.par));
      }
      drawItem(item, screenX, groundSY);
    });
  });

  // Dust
  dust.forEach(p => {
    cx.save(); cx.globalAlpha=p.life*0.62;
    if(p.leaf){
      cx.fillStyle='#7a9848'; cx.save(); cx.translate(p.x,p.y); cx.rotate(t*3+p.sz);
      cx.beginPath(); cx.ellipse(0,0,p.sz*2,p.sz,0,0,Math.PI*2); cx.fill(); cx.restore();
    } else {
      cx.fillStyle='#bfa060'; cx.beginPath(); cx.arc(p.x,p.y,p.sz*0.58,0,Math.PI*2); cx.fill();
    }
    cx.restore();
  });

  // Bike (always at screen center W/2, vertically on terrain + bounce)
  drawBike(W/2, bY+jmp, velX, lean, fRot, rRot, bAngle);

  // Vignette
  const vig = cx.createRadialGradient(W/2,H/2,H*0.26,W/2,H/2,H*0.80);
  vig.addColorStop(0,'rgba(237,234,224,0)');
  vig.addColorStop(1,'rgba(205,192,165,0.28)');
  cx.fillStyle=vig; cx.fillRect(0,0,W,H);

  requestAnimationFrame(loop);
}
requestAnimationFrame(ts => { last=ts; requestAnimationFrame(loop); });
</script>
</body>
</html>
